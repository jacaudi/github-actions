name: Lint
# Multi-language linting reusable workflow supporting Python, Go, Shell, YAML, and Helm

on:
  workflow_call:
    inputs:
      python:
        description: 'Enable Python linting with ruff'
        required: false
        type: boolean
        default: false
      python-version:
        description: 'Python version to use for ruff'
        required: false
        type: string
        default: '3.12'
      ruff-version:
        description: 'Ruff version to install (empty for latest)'
        required: false
        type: string
        default: ''
      ruff-args:
        description: 'Additional arguments to pass to ruff check'
        required: false
        type: string
        default: '.'
      go:
        description: 'Enable Go linting with golangci-lint'
        required: false
        type: boolean
        default: false
      go-version:
        description: 'Go version to use'
        required: false
        type: string
        default: 'stable'
      golangci-lint-version:
        description: 'golangci-lint version to install'
        required: false
        type: string
        default: 'latest'
      golangci-lint-args:
        description: 'Additional arguments to pass to golangci-lint'
        required: false
        type: string
        default: ''
      shell:
        description: 'Enable shell script linting with shellcheck'
        required: false
        type: boolean
        default: false
      shellcheck-version:
        description: 'ShellCheck version to use'
        required: false
        type: string
        default: 'stable'
      shellcheck-paths:
        description: 'Paths to check for shell scripts (space-separated)'
        required: false
        type: string
        default: '.'
      shellcheck-args:
        description: 'Additional arguments to pass to shellcheck'
        required: false
        type: string
        default: ''
      yaml:
        description: 'Enable YAML linting with yamllint'
        required: false
        type: boolean
        default: false
      yamllint-config:
        description: 'Path to yamllint config file'
        required: false
        type: string
        default: ''
      yamllint-args:
        description: 'Additional arguments to pass to yamllint'
        required: false
        type: string
        default: '.'
      helm:
        description: 'Enable Helm chart linting'
        required: false
        type: boolean
        default: false
      helm-chart-path:
        description: 'Path to Helm chart(s) to lint'
        required: false
        type: string
        default: 'charts/'
      helm-args:
        description: 'Additional arguments to pass to helm lint'
        required: false
        type: string
        default: ''
      json:
        description: 'Enable JSON linting with jq'
        required: false
        type: boolean
        default: false
      json-paths:
        description: 'Paths/globs to check for JSON files (space-separated)'
        required: false
        type: string
        default: '.'
      json-exclude:
        description: 'Patterns to exclude from JSON linting (space-separated)'
        required: false
        type: string
        default: 'node_modules .git'
      working-directory:
        description: 'Working directory for all lint commands'
        required: false
        type: string
        default: '.'
      fail-fast:
        description: 'Stop on first linter failure'
        required: false
        type: boolean
        default: true
      upload-artifact:
        description: 'Upload lint results as artifact'
        required: false
        type: boolean
        default: true
      artifact-name:
        description: 'Name for lint result artifacts'
        required: false
        type: string
        default: 'lint-results'
      artifact-retention-days:
        description: 'Number of days to retain lint artifacts'
        required: false
        type: number
        default: 7
    outputs:
      python-status:
        description: 'Python lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.python-status }}
      go-status:
        description: 'Go lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.go-status }}
      shell-status:
        description: 'Shell lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.shell-status }}
      yaml-status:
        description: 'YAML lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.yaml-status }}
      helm-status:
        description: 'Helm lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.helm-status }}
      json-status:
        description: 'JSON lint result: success, failure, or skipped'
        value: ${{ jobs.summary.outputs.json-status }}
      overall-status:
        description: 'Overall lint result: success or failure'
        value: ${{ jobs.summary.outputs.overall-status }}
      lint-report:
        description: 'Combined JSON lint report with standardized schema'
        value: ${{ jobs.summary.outputs.lint-report }}

jobs:
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-linters: ${{ steps.set-matrix.outputs.has-linters }}
    steps:
      - name: Build linter matrix
        id: set-matrix
        run: |
          LINTERS="[]"

          if [[ "${{ inputs.python }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["python"]')
          fi
          if [[ "${{ inputs.go }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["go"]')
          fi
          if [[ "${{ inputs.shell }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["shell"]')
          fi
          if [[ "${{ inputs.yaml }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["yaml"]')
          fi
          if [[ "${{ inputs.helm }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["helm"]')
          fi
          if [[ "${{ inputs.json }}" == "true" ]]; then
            LINTERS=$(echo "$LINTERS" | jq -c '. + ["json"]')
          fi

          echo "matrix={\"linter\":$LINTERS}" >> $GITHUB_OUTPUT

          if [[ "$LINTERS" == "[]" ]]; then
            echo "has-linters=false" >> $GITHUB_OUTPUT
          else
            echo "has-linters=true" >> $GITHUB_OUTPUT
          fi

          echo "Generated matrix: {\"linter\":$LINTERS}"

  lint:
    name: Lint (${{ matrix.linter }})
    needs: setup
    if: needs.setup.outputs.has-linters == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: ${{ inputs.fail-fast }}
      matrix: ${{ fromJSON(needs.setup.outputs.matrix) }}
    outputs:
      status: ${{ steps.run-linter.outputs.status }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Create results directory
        run: mkdir -p .lint-results

      # Python Linting with Ruff
      - name: Set up Python
        if: matrix.linter == 'python'
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.python-version }}

      - name: Install Ruff
        if: matrix.linter == 'python'
        run: |
          if [[ -n "${{ inputs.ruff-version }}" ]]; then
            pip install ruff==${{ inputs.ruff-version }}
          else
            pip install ruff
          fi

      - name: Run Ruff
        id: python-lint
        if: matrix.linter == 'python'
        continue-on-error: true
        run: |
          echo "::group::Ruff Output"
          # Output JSON for artifacts and console for visibility
          ruff check --output-format json ${{ inputs.ruff-args }} > .lint-results/ruff.json 2>&1 || true
          ruff check ${{ inputs.ruff-args }}
          echo "::endgroup::"

      - name: Generate Python lint report
        if: matrix.linter == 'python' && always()
        continue-on-error: true
        run: |
          RUFF_VERSION=$(ruff --version 2>/dev/null | awk '{print $2}' || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if [[ -f .lint-results/ruff.json ]] && jq empty .lint-results/ruff.json 2>/dev/null; then
            jq -n \
              --arg linter "ruff" \
              --arg version "$RUFF_VERSION" \
              --arg timestamp "$TIMESTAMP" \
              --arg status "${{ steps.python-lint.outcome }}" \
              --slurpfile raw .lint-results/ruff.json '
              ($raw[0] // []) as $issues |
              {
                linter: $linter,
                version: $version,
                timestamp: $timestamp,
                status: $status,
                summary: {
                  errors: ([$issues[] | select(.code | startswith("E"))] | length),
                  warnings: ([$issues[] | select(.code | startswith("E") | not)] | length),
                  total: ($issues | length)
                },
                issues: [
                  $issues[] | {
                    file: .filename,
                    line: .location.row,
                    column: .location.column,
                    severity: (if (.code | startswith("E")) then "error" else "warning" end),
                    rule: .code,
                    message: .message
                  }
                ]
              }' > .lint-results/lint-report.json
          else
            jq -n --arg linter "ruff" --arg version "$RUFF_VERSION" --arg timestamp "$TIMESTAMP" --arg status "${{ steps.python-lint.outcome }}" \
              '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: 0, warnings: 0, total: 0}, issues: []}' \
              > .lint-results/lint-report.json
          fi

      # Go Linting with golangci-lint
      - name: Set up Go
        if: matrix.linter == 'go'
        uses: actions/setup-go@v6
        with:
          go-version: ${{ inputs.go-version }}

      - name: Run golangci-lint
        id: go-lint
        if: matrix.linter == 'go'
        uses: golangci/golangci-lint-action@v9
        continue-on-error: true
        with:
          version: ${{ inputs.golangci-lint-version }}
          args: ${{ inputs.golangci-lint-args }}
          working-directory: ${{ inputs.working-directory }}

      - name: Save golangci-lint JSON output
        if: matrix.linter == 'go' && always()
        continue-on-error: true
        run: |
          golangci-lint run --out-format json ${{ inputs.golangci-lint-args }} > .lint-results/golangci-lint.json 2>&1 || true

      - name: Generate Go lint report
        if: matrix.linter == 'go' && always()
        continue-on-error: true
        run: |
          GC_VERSION=$(golangci-lint --version 2>/dev/null | grep -oP 'v?\K[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if [[ -f .lint-results/golangci-lint.json ]] && jq empty .lint-results/golangci-lint.json 2>/dev/null; then
            jq -n \
              --arg linter "golangci-lint" \
              --arg version "$GC_VERSION" \
              --arg timestamp "$TIMESTAMP" \
              --arg status "${{ steps.go-lint.outcome }}" \
              --slurpfile raw .lint-results/golangci-lint.json '
              (($raw[0].Issues // []) | map(select(. != null))) as $issues |
              {
                linter: $linter,
                version: $version,
                timestamp: $timestamp,
                status: $status,
                summary: {
                  errors: ([$issues[] | select(.Severity == "error" or .Severity == null)] | length),
                  warnings: ([$issues[] | select(.Severity == "warning")] | length),
                  total: ($issues | length)
                },
                issues: [
                  $issues[] | {
                    file: .Pos.Filename,
                    line: .Pos.Line,
                    column: .Pos.Column,
                    severity: (if .Severity == "warning" then "warning" else "error" end),
                    rule: .FromLinter,
                    message: .Text
                  }
                ]
              }' > .lint-results/lint-report.json
          else
            jq -n --arg linter "golangci-lint" --arg version "$GC_VERSION" --arg timestamp "$TIMESTAMP" --arg status "${{ steps.go-lint.outcome }}" \
              '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: 0, warnings: 0, total: 0}, issues: []}' \
              > .lint-results/lint-report.json
          fi

      # Shell Linting with ShellCheck
      - name: Run ShellCheck
        id: shell-lint
        if: matrix.linter == 'shell'
        uses: ludeeus/action-shellcheck@2.0.0
        continue-on-error: true
        with:
          version: ${{ inputs.shellcheck-version }}
          scandir: ${{ inputs.shellcheck-paths }}
          additional_files: ${{ inputs.shellcheck-args }}

      - name: Save ShellCheck JSON output
        if: matrix.linter == 'shell' && always()
        continue-on-error: true
        run: |
          # Find shell scripts and run shellcheck with JSON output
          find ${{ inputs.shellcheck-paths }} -type f \( -name "*.sh" -o -name "*.bash" \) -print0 2>/dev/null | \
            xargs -0 shellcheck --format=json ${{ inputs.shellcheck-args }} > .lint-results/shellcheck.json 2>&1 || true

      - name: Generate Shell lint report
        if: matrix.linter == 'shell' && always()
        continue-on-error: true
        run: |
          SC_VERSION=$(shellcheck --version 2>/dev/null | grep 'version:' | awk '{print $2}' || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if [[ -f .lint-results/shellcheck.json ]] && jq empty .lint-results/shellcheck.json 2>/dev/null; then
            jq -n \
              --arg linter "shellcheck" \
              --arg version "$SC_VERSION" \
              --arg timestamp "$TIMESTAMP" \
              --arg status "${{ steps.shell-lint.outcome }}" \
              --slurpfile raw .lint-results/shellcheck.json '
              ($raw[0] // []) as $issues |
              {
                linter: $linter,
                version: $version,
                timestamp: $timestamp,
                status: $status,
                summary: {
                  errors: ([$issues[] | select(.level == "error")] | length),
                  warnings: ([$issues[] | select(.level == "warning")] | length),
                  total: ($issues | length)
                },
                issues: [
                  $issues[] | {
                    file: .file,
                    line: .line,
                    column: .column,
                    severity: .level,
                    rule: ("SC" + (.code | tostring)),
                    message: .message
                  }
                ]
              }' > .lint-results/lint-report.json
          else
            jq -n --arg linter "shellcheck" --arg version "$SC_VERSION" --arg timestamp "$TIMESTAMP" --arg status "${{ steps.shell-lint.outcome }}" \
              '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: 0, warnings: 0, total: 0}, issues: []}' \
              > .lint-results/lint-report.json
          fi

      # YAML Linting with yamllint
      - name: Install yamllint
        if: matrix.linter == 'yaml'
        run: pip install yamllint

      - name: Run yamllint
        id: yaml-lint
        if: matrix.linter == 'yaml'
        continue-on-error: true
        run: |
          echo "::group::yamllint Output"
          if [[ -n "${{ inputs.yamllint-config }}" ]]; then
            # Output parseable format for artifacts
            yamllint -f parsable -c "${{ inputs.yamllint-config }}" ${{ inputs.yamllint-args }} > .lint-results/yamllint.txt 2>&1 || true
            # Run again for console output
            yamllint -c "${{ inputs.yamllint-config }}" ${{ inputs.yamllint-args }}
          else
            # Output parseable format for artifacts
            yamllint -f parsable ${{ inputs.yamllint-args }} > .lint-results/yamllint.txt 2>&1 || true
            # Run again for console output
            yamllint ${{ inputs.yamllint-args }}
          fi
          echo "::endgroup::"

      - name: Generate YAML lint report
        if: matrix.linter == 'yaml' && always()
        continue-on-error: true
        run: |
          YL_VERSION=$(yamllint --version 2>/dev/null | awk '{print $2}' || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ISSUES="[]"
          ERRORS=0
          WARNINGS=0
          if [[ -f .lint-results/yamllint.txt ]]; then
            while IFS= read -r line; do
              # parsable format: file:line:col: [error|warning] message (rule)
              if [[ "$line" =~ ^(.+):([0-9]+):([0-9]+):\ \[(error|warning)\]\ (.+)\ \((.+)\)$ ]]; then
                FILE="${BASH_REMATCH[1]}"
                LINE="${BASH_REMATCH[2]}"
                COL="${BASH_REMATCH[3]}"
                SEVERITY="${BASH_REMATCH[4]}"
                MSG="${BASH_REMATCH[5]}"
                RULE="${BASH_REMATCH[6]}"
                ISSUES=$(echo "$ISSUES" | jq -c \
                  --arg file "$FILE" --argjson line "$LINE" --argjson col "$COL" \
                  --arg severity "$SEVERITY" --arg rule "$RULE" --arg msg "$MSG" \
                  '. + [{file: $file, line: $line, column: $col, severity: $severity, rule: $rule, message: $msg}]')
                if [[ "$SEVERITY" == "error" ]]; then ERRORS=$((ERRORS+1)); else WARNINGS=$((WARNINGS+1)); fi
              fi
            done < .lint-results/yamllint.txt
          fi
          TOTAL=$((ERRORS + WARNINGS))
          jq -n \
            --arg linter "yamllint" --arg version "$YL_VERSION" --arg timestamp "$TIMESTAMP" \
            --arg status "${{ steps.yaml-lint.outcome }}" \
            --argjson errors "$ERRORS" --argjson warnings "$WARNINGS" --argjson total "$TOTAL" \
            --argjson issues "$ISSUES" \
            '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: $errors, warnings: $warnings, total: $total}, issues: $issues}' \
            > .lint-results/lint-report.json

      # Helm Linting
      - name: Set up Helm
        if: matrix.linter == 'helm'
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Run Helm lint
        id: helm-lint
        if: matrix.linter == 'helm'
        continue-on-error: true
        run: |
          echo "::group::Helm Lint Output"
          # Handle both single chart and multiple charts in directory
          CHART_PATH="${{ inputs.helm-chart-path }}"
          if [[ -f "${CHART_PATH}/Chart.yaml" ]]; then
            helm lint "${CHART_PATH}" ${{ inputs.helm-args }} 2>&1 | tee .lint-results/helm-lint.txt
          else
            # Find all charts in the directory
            found_charts=0
            for chart in "${CHART_PATH}"/*/Chart.yaml; do
              if [[ -f "$chart" ]]; then
                chart_dir=$(dirname "$chart")
                echo "Linting chart: $chart_dir"
                helm lint "$chart_dir" ${{ inputs.helm-args }} 2>&1 | tee -a .lint-results/helm-lint.txt
                found_charts=1
              fi
            done
            if [[ $found_charts -eq 0 ]]; then
              echo "::warning::No Helm charts found in ${CHART_PATH}"
            fi
          fi
          echo "::endgroup::"

      - name: Generate Helm lint report
        if: matrix.linter == 'helm' && always()
        continue-on-error: true
        run: |
          HELM_VERSION=$(helm version --short 2>/dev/null | grep -oP 'v?\K[0-9]+\.[0-9]+\.[0-9]+' || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ISSUES="[]"
          ERRORS=0
          WARNINGS=0
          if [[ -f .lint-results/helm-lint.txt ]]; then
            while IFS= read -r line; do
              if [[ "$line" =~ ^\[ERROR\]\ (.+) ]]; then
                MSG="${BASH_REMATCH[1]}"
                ISSUES=$(echo "$ISSUES" | jq -c --arg msg "$MSG" '. + [{file: "", line: 0, column: 0, severity: "error", rule: "helm-lint", message: $msg}]')
                ERRORS=$((ERRORS+1))
              elif [[ "$line" =~ ^\[WARNING\]\ (.+) ]]; then
                MSG="${BASH_REMATCH[1]}"
                ISSUES=$(echo "$ISSUES" | jq -c --arg msg "$MSG" '. + [{file: "", line: 0, column: 0, severity: "warning", rule: "helm-lint", message: $msg}]')
                WARNINGS=$((WARNINGS+1))
              fi
            done < .lint-results/helm-lint.txt
          fi
          TOTAL=$((ERRORS + WARNINGS))
          jq -n \
            --arg linter "helm" --arg version "$HELM_VERSION" --arg timestamp "$TIMESTAMP" \
            --arg status "${{ steps.helm-lint.outcome }}" \
            --argjson errors "$ERRORS" --argjson warnings "$WARNINGS" --argjson total "$TOTAL" \
            --argjson issues "$ISSUES" \
            '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: $errors, warnings: $warnings, total: $total}, issues: $issues}' \
            > .lint-results/lint-report.json

      # JSON Linting with jq
      - name: Run JSON lint
        id: json-lint
        if: matrix.linter == 'json'
        continue-on-error: true
        run: |
          echo "::group::JSON Lint Output"

          # Build exclude pattern for find
          EXCLUDE_ARGS=""
          for pattern in ${{ inputs.json-exclude }}; do
            EXCLUDE_ARGS="${EXCLUDE_ARGS} -path '*/${pattern}/*' -prune -o"
          done

          # Find and validate JSON files
          FAILED=0
          CHECKED=0
          RESULTS="[]"

          while IFS= read -r -d '' file; do
            CHECKED=$((CHECKED + 1))
            if ERROR=$(jq empty "$file" 2>&1); then
              echo "OK: $file"
            else
              echo "FAIL: $file"
              echo "  Error: $ERROR"
              FAILED=$((FAILED + 1))
              RESULTS=$(echo "$RESULTS" | jq --arg file "$file" --arg error "$ERROR" '. + [{"file": $file, "error": $error}]')
            fi
          done < <(eval "find ${{ inputs.json-paths }} ${EXCLUDE_ARGS} -type f -name '*.json' -print0 2>/dev/null")

          # Save results
          echo "$RESULTS" > .lint-results/json-lint.json

          echo ""
          echo "Checked ${CHECKED} JSON files, ${FAILED} failed"

          echo "::endgroup::"

          if [[ ${FAILED} -gt 0 ]]; then
            echo "::error::${FAILED} JSON file(s) contain invalid syntax"
            exit 1
          fi

      - name: Generate JSON lint report
        if: matrix.linter == 'json' && always()
        continue-on-error: true
        run: |
          JQ_VERSION=$(jq --version 2>/dev/null | sed 's/jq-//' || echo "unknown")
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if [[ -f .lint-results/json-lint.json ]] && jq empty .lint-results/json-lint.json 2>/dev/null; then
            jq -n \
              --arg linter "jq" \
              --arg version "$JQ_VERSION" \
              --arg timestamp "$TIMESTAMP" \
              --arg status "${{ steps.json-lint.outcome }}" \
              --slurpfile raw .lint-results/json-lint.json '
              ($raw[0] // []) as $issues |
              {
                linter: $linter,
                version: $version,
                timestamp: $timestamp,
                status: $status,
                summary: {
                  errors: ($issues | length),
                  warnings: 0,
                  total: ($issues | length)
                },
                issues: [
                  $issues[] | {
                    file: .file,
                    line: 0,
                    column: 0,
                    severity: "error",
                    rule: "json-syntax",
                    message: .error
                  }
                ]
              }' > .lint-results/lint-report.json
          else
            jq -n --arg linter "jq" --arg version "$JQ_VERSION" --arg timestamp "$TIMESTAMP" --arg status "${{ steps.json-lint.outcome }}" \
              '{linter: $linter, version: $version, timestamp: $timestamp, status: $status, summary: {errors: 0, warnings: 0, total: 0}, issues: []}' \
              > .lint-results/lint-report.json
          fi

      # Set linter status based on which linter ran
      - name: Set linter status
        id: run-linter
        if: always()
        run: |
          LINTER="${{ matrix.linter }}"
          STATUS="skipped"

          case "$LINTER" in
            python) STATUS="${{ steps.python-lint.outcome }}" ;;
            go) STATUS="${{ steps.go-lint.outcome }}" ;;
            shell) STATUS="${{ steps.shell-lint.outcome }}" ;;
            yaml) STATUS="${{ steps.yaml-lint.outcome }}" ;;
            helm) STATUS="${{ steps.helm-lint.outcome }}" ;;
            json) STATUS="${{ steps.json-lint.outcome }}" ;;
          esac

          echo "status=${STATUS:-skipped}" >> $GITHUB_OUTPUT
          echo "Linter $LINTER status: ${STATUS:-skipped}"

      # Upload Lint Artifacts
      - name: Upload Lint Artifacts
        if: always() && inputs.upload-artifact
        uses: actions/upload-artifact@v7
        with:
          name: ${{ inputs.artifact-name }}-${{ matrix.linter }}
          path: ${{ inputs.working-directory == '.' && format('{0}/.lint-results/', github.workspace) || format('{0}/{1}/.lint-results/', github.workspace, inputs.working-directory) }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: ignore
          include-hidden-files: true

  summary:
    name: Lint Summary
    needs: [setup, lint]
    if: always()
    runs-on: ubuntu-latest
    outputs:
      python-status: ${{ steps.collect.outputs.python-status }}
      go-status: ${{ steps.collect.outputs.go-status }}
      shell-status: ${{ steps.collect.outputs.shell-status }}
      yaml-status: ${{ steps.collect.outputs.yaml-status }}
      helm-status: ${{ steps.collect.outputs.helm-status }}
      json-status: ${{ steps.collect.outputs.json-status }}
      overall-status: ${{ steps.collect.outputs.overall-status }}
      lint-report: ${{ steps.combine-reports.outputs.lint-report }}
    steps:
      - name: Download lint artifacts
        if: always() && inputs.upload-artifact && needs.setup.outputs.has-linters == 'true'
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: ${{ inputs.artifact-name }}-*
          path: .lint-artifacts
          merge-multiple: false

      - name: Combine lint reports
        id: combine-reports
        if: always()
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPORTS="[]"

          # Find all lint-report.json files from downloaded artifacts
          if [[ -d .lint-artifacts ]]; then
            while IFS= read -r report; do
              if jq empty "$report" 2>/dev/null; then
                REPORTS=$(jq -c --slurpfile r "$report" '. + [$r[0]]' <<< "$REPORTS")
              fi
            done < <(find .lint-artifacts -name "lint-report.json" -type f 2>/dev/null)
          fi

          # Build combined report
          COMBINED=$(jq -n \
            --arg timestamp "$TIMESTAMP" \
            --argjson reports "$REPORTS" '
            {
              timestamp: $timestamp,
              summary: {
                total_errors: ([$reports[].summary.errors] | add // 0),
                total_warnings: ([$reports[].summary.warnings] | add // 0),
                total_issues: ([$reports[].summary.total] | add // 0),
                linters_run: ($reports | length)
              },
              linters: $reports
            }')

          # Output as a step output (escaped for multiline)
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "lint-report<<${EOF}" >> $GITHUB_OUTPUT
          echo "$COMBINED" >> $GITHUB_OUTPUT
          echo "${EOF}" >> $GITHUB_OUTPUT

          # Also write to file for artifact upload
          mkdir -p .lint-combined
          echo "$COMBINED" > .lint-combined/lint-report.json
          echo "Combined lint report generated with $(echo "$REPORTS" | jq length) linter(s)"

      - name: Upload combined lint report
        if: always() && inputs.upload-artifact
        uses: actions/upload-artifact@v7
        continue-on-error: true
        with:
          name: ${{ inputs.artifact-name }}-combined
          path: .lint-combined/lint-report.json
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: ignore

      - name: Collect Results
        id: collect
        run: |
          MATRIX='${{ needs.setup.outputs.matrix }}'
          LINT_RESULT='${{ needs.lint.result }}'

          echo "python-status=skipped" >> $GITHUB_OUTPUT
          echo "go-status=skipped" >> $GITHUB_OUTPUT
          echo "shell-status=skipped" >> $GITHUB_OUTPUT
          echo "yaml-status=skipped" >> $GITHUB_OUTPUT
          echo "helm-status=skipped" >> $GITHUB_OUTPUT
          echo "json-status=skipped" >> $GITHUB_OUTPUT

          if [[ "${{ needs.setup.outputs.has-linters }}" == "true" ]]; then
            if echo "$MATRIX" | jq -e '.linter | index("python")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "python-status=success" >> $GITHUB_OUTPUT
              else
                echo "python-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
            if echo "$MATRIX" | jq -e '.linter | index("go")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "go-status=success" >> $GITHUB_OUTPUT
              else
                echo "go-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
            if echo "$MATRIX" | jq -e '.linter | index("shell")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "shell-status=success" >> $GITHUB_OUTPUT
              else
                echo "shell-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
            if echo "$MATRIX" | jq -e '.linter | index("yaml")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "yaml-status=success" >> $GITHUB_OUTPUT
              else
                echo "yaml-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
            if echo "$MATRIX" | jq -e '.linter | index("helm")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "helm-status=success" >> $GITHUB_OUTPUT
              else
                echo "helm-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
            if echo "$MATRIX" | jq -e '.linter | index("json")' > /dev/null; then
              if [[ "$LINT_RESULT" == "success" ]]; then
                echo "json-status=success" >> $GITHUB_OUTPUT
              else
                echo "json-status=failure" >> $GITHUB_OUTPUT
              fi
            fi
          fi

          if [[ "$LINT_RESULT" == "success" ]] || [[ "${{ needs.setup.outputs.has-linters }}" == "false" ]]; then
            echo "overall-status=success" >> $GITHUB_OUTPUT
          else
            echo "overall-status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Generate Summary
        if: always()
        run: |
          echo "## Lint Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Linter | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY

          case "${{ steps.collect.outputs.python-status }}" in
            success) echo "| :snake: Python (ruff) | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :snake: Python (ruff) | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :snake: Python (ruff) | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          case "${{ steps.collect.outputs.go-status }}" in
            success) echo "| :blue_square: Go (golangci-lint) | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :blue_square: Go (golangci-lint) | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :blue_square: Go (golangci-lint) | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          case "${{ steps.collect.outputs.shell-status }}" in
            success) echo "| :shell: Shell (shellcheck) | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :shell: Shell (shellcheck) | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :shell: Shell (shellcheck) | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          case "${{ steps.collect.outputs.yaml-status }}" in
            success) echo "| :page_facing_up: YAML (yamllint) | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :page_facing_up: YAML (yamllint) | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :page_facing_up: YAML (yamllint) | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          case "${{ steps.collect.outputs.helm-status }}" in
            success) echo "| :wheel_of_dharma: Helm | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :wheel_of_dharma: Helm | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :wheel_of_dharma: Helm | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          case "${{ steps.collect.outputs.json-status }}" in
            success) echo "| :card_file_box: JSON (jq) | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY ;;
            failure) echo "| :card_file_box: JSON (jq) | :x: Failed |" >> $GITHUB_STEP_SUMMARY ;;
            *) echo "| :card_file_box: JSON (jq) | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY ;;
          esac

          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.collect.outputs.overall-status }}" == "success" ]]; then
            echo "**Overall Status:** :white_check_mark: All checks passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Overall Status:** :x: Some checks failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Fail if linters failed
        if: steps.collect.outputs.overall-status == 'failure'
        run: exit 1
